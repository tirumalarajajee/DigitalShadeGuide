<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tooth Shade Detection</title>
  <style>
   body { font-family: sans-serif; text-align: center; background: #f0f0f0; }
#camera { display: none; }
#snapshot { display: block; margin: 10px auto; border: 1px solid #000; }

    #confidenceFill {
      height: 20px;
      background: gray;
      width: 100px;
      margin: auto;
      color: white;
      line-height: 20px;
    }
  </style>
</head>
<body>

  <h2>ðŸ¦· Detection Mode</h2>
  <video id="camera" autoplay playsinline width="640" height="480"></video>
  <canvas id="snapshot" width="640" height="480" style="border:1px solid #000;"></canvas>

  <br />
  <label for="modeSelector">Detection Mode:</label>
  <select id="modeSelector">
    <option value="single">Single</option>
    <option value="region">Region</option>
    <option value="merge">Merged</option>
  </select>

  <p id="liveShade">Shade: ---</p>
  <div id="confidenceFill">Î”E00: ---</div>

  <br />
  <button id="saveSingle">Save Single</button>
  <button id="saveRegion">Save Region</button>
  <button id="saveMerge">Save Merged</button>

  <script>

let speechUnlocked = false;

document.body.addEventListener("click", () => {
  if (!speechUnlocked && "speechSynthesis" in window) {
    const u = new SpeechSynthesisUtterance(" ");
    speechSynthesis.speak(u);
    speechUnlocked = true;
    console.log("[Speech] Speech synthesis unlocked by user gesture");
  }
}, { once: true });




let lastSpokenShade = null;
let lastSpokenTime = 0;
const SPEAK_INTERVAL_MS = 3000; // minimum gap between announcements


   const DB_NAME = "DigitalShadeDB";
const DB_VERSION = 1;
const SHADE_STORE = "shades";
const META_STORE = "meta";


async function startUsbCameraEdge() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === "videoinput");

  console.table(cams.map(c => c.label));

  const usbCam = cams.find(c =>
    /usb|uvc|endoscope|camera/i.test(c.label) &&
    !/integrated|built-in|laptop/i.test(c.label)
  );

  if (!usbCam) {
    console.warn("[Camera] USB camera not found, using default");
  }

  const stream = await navigator.mediaDevices.getUserMedia({
    video: {
      deviceId: usbCam ? { exact: usbCam.deviceId } : undefined,
      width: { ideal: 640 },
      height: { ideal: 480 }
    }
  });

  video.srcObject = stream;

  console.log("[Camera] Using:", usbCam?.label || "default");
}



function speakShade(shade, delta) {
  console.log("[Speech] speakShade called:", shade, "Î”", delta.toFixed(2));

  if (!speechUnlocked) {
    console.warn("[Speech] Blocked: speech not unlocked yet");
    return;
  }

  if (!("speechSynthesis" in window)) {
    console.error("[Speech] Web Speech API not supported");
    return;
  }

  if (!shade || shade === "---") {
    console.warn("[Speech] Invalid shade, skipping");
    return;
  }

  if (shade === lastSpokenShade) {
    console.log("[Speech] Same shade as last, skipping");
    return;
  }

  const utterance = new SpeechSynthesisUtterance(shade);

  utterance.rate = 0.9;
  utterance.pitch = 1.0;
  utterance.volume = 1.0;

  speechSynthesis.cancel();
  speechSynthesis.speak(utterance);

  lastSpokenShade = shade;

  console.log("[Speech] Speaking shade:", shade);
}



let webShades = {}; // will be populated from IndexedDB

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(SHADE_STORE))
        db.createObjectStore(SHADE_STORE, { keyPath: "shadeCode" });
      if (!db.objectStoreNames.contains(META_STORE))
        db.createObjectStore(META_STORE, { keyPath: "key" });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function getStoredVersion(db) {
  return new Promise(res => {
    const tx = db.transaction(META_STORE, "readonly");
    const req = tx.objectStore(META_STORE).get("version");
    req.onsuccess = () => res(req.result?.value || null);
  });
}

async function syncShades() {
  console.log("[ShadeDB] Sync started");

  const db = await openDB();
  const json = await fetch("shades.json").then(r => r.json());

  console.log("[ShadeDB] JSON version:", json.version);

  const storedVersion = await getStoredVersion(db);
  console.log("[ShadeDB] Cached version:", storedVersion);

  if (storedVersion === json.version) {
    console.log("[ShadeDB] Using cached shades (IndexedDB)");
    await loadShadesFromDB(db);
    return;
  }

  console.log(`[ShadeDB] Updating cache: ${storedVersion} â†’ ${json.version}`);

  const tx = db.transaction([SHADE_STORE, META_STORE], "readwrite");
  const shadeStore = tx.objectStore(SHADE_STORE);

  shadeStore.clear();
  console.log("[ShadeDB] Cleared old shade records");

  for (const [shadeCode, rgb] of Object.entries(json.shades)) {
    shadeStore.put({ shadeCode, rgb });
  }

  tx.objectStore(META_STORE).put({
    key: "version",
    value: json.version
  });

  await tx.complete;

  console.log("[ShadeDB] Cache update complete");
  await loadShadesFromDB(db);
}


async function loadShadesFromDB(db) {
  webShades = {};
  let count = 0;

  return new Promise(resolve => {
    const tx = db.transaction(SHADE_STORE, "readonly");
    const req = tx.objectStore(SHADE_STORE).openCursor();

    req.onsuccess = e => {
      const cursor = e.target.result;
      if (cursor) {
        webShades[cursor.value.shadeCode] = cursor.value.rgb;
        count++;
        cursor.continue();
      } else {
        console.log(`[ShadeDB] Loaded ${count} shades from cache`);
        resolve();
      }
    };
  });
}

    const regions = {
      region: ["Incisal", "Middle", "Cervical"],
      merge: ["Mesial", "Prime", "Distal"]
    };

    let regionIndex = 0;
    const video = document.getElementById("camera");
    const canvas = document.getElementById("snapshot");
    const ctx = canvas.getContext("2d");
    const modeSelector = document.getElementById("modeSelector");
    const shadeLive = document.getElementById("liveShade");
    const confidenceFill = document.getElementById("confidenceFill");

    function getRegionLabel(mode) {
      if (mode === "single") return "Whole";
      const list = regions[mode];
      return list[regionIndex++ % list.length];
    }

    function getAverageRGB(data) {
      const pixels = [];
      for (let i = 0; i < data.length; i += 4) {
        pixels.push([data[i], data[i + 1], data[i + 2]]);
      }
      return pixels.reduce((a, b) => a.map((v, i) => v + b[i]), [0, 0, 0])
                   .map(v => v / pixels.length);
    }

    function rgbToLab([r, g, b]) {
      [r, g, b] = [r, g, b].map(v => {
        v /= 255;
        return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
      });
      let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
      let y = (r * 0.2126 + g * 0.7152 + b * 0.0722);
      let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
      [x, y, z] = [x, y, z].map(v => v > 0.008856 ? Math.pow(v, 1/3) : (7.787 * v) + 16/116);
      return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)];
    }

    function findClosestShade(rgb) {
      if (!Object.keys(webShades).length) {
    console.warn("[ShadeDB] Shade map not loaded yet");
    return ["---", Infinity];
  }
      const sampleLab = rgbToLab(rgb);
      let minDelta = Infinity, bestShade = "---";
      for (const shade in webShades) {
        const lab = rgbToLab(webShades[shade]);
        const delta = Math.sqrt(sampleLab.reduce((sum, v, i) => sum + Math.pow(v - lab[i], 2), 0));
        if (delta < minDelta) {
          minDelta = delta;
          bestShade = shade;
        }
      }
       speakShade(bestShade, minDelta);
      return [bestShade, minDelta];
    }

    navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } }).then(stream => {
      video.srcObject = stream;

      setInterval(() => {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const radius = 80;
        const data = ctx.getImageData(canvas.width/2 - radius, canvas.height/2 - radius, radius*2, radius*2).data;
        const avg = getAverageRGB(data);
        const [shade, delta] = findClosestShade(avg);
        const region = getRegionLabel(modeSelector.value);

        shadeLive.textContent = `Shade: ${shade} | Region: ${region}`;
        confidenceFill.textContent = `Î”E00: ${delta.toFixed(2)}`;
        confidenceFill.style.width = Math.min(100, 100 - delta * 5) + "%";
        confidenceFill.style.backgroundColor = delta < 3 ? "green" : delta < 6 ? "orange" : "red";
      }, 100);
    });

    function saveModeSnapshot(mode) {
      const snapshotURL = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = snapshotURL;
      a.download = `${mode}_shade_${Date.now()}.png`;
      a.click();
    }

    document.getElementById("saveSingle").onclick = () => saveModeSnapshot("single");
    document.getElementById("saveRegion").onclick = () => saveModeSnapshot("region");
    document.getElementById("saveMerge").onclick = () => saveModeSnapshot("merge");

    startUsbCameraEdge();


    syncShades();

  </script>
</body>
</html>
